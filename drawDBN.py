# drawDBN.py
#
# Created by Michael Walker 29/10/2014
# Emails: walkerm1@student.unimelb.edu.au, m.walker@aip.org.au  
#
# Scripts to draw DBNs generated by either ARTiVa or bnlearn
# Loads dumped DBNs from either graphBNLEARN.py or graphARTIVA.py
#

import networkx as nx
import sys,pickle,os
#import pickle as pickle
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
#import EasyDialogs

from string import split,replace,find,digits,replace,strip

styles = mpatches.ArrowStyle.get_styles()

def drawDBN(_dbnstring,_drawout,cutoff=0):
    """Function to draw DBN. 
    
    Calls:
        dbnpos() - dictionary of node positions.
    """
    global actlines,widthcoeff
    
    # Load DBN from _dbnfile
    _dbnfile = file(_dbnstring,'r')
    dbn = pickle.load(_dbnfile)
    _dbnfile.close()
    
    _outdir,_figtitle = os.path.split(_drawout)    # directory and title of saved figure
    
    # Set up figure
    fig,ax = plt.subplots()
    xfig,yfig = fig.get_size_inches()
    fig.set_size_inches(xfig,len(dbn.graph['nodes'])*1.1,forward=True)
    #_nodes = dbn.graph['nodes']
    _pos = dbnpos(dbn)
    _base_alpha = dbn.graph['base_alpha']    # _alpha value indicates posterior of edge
    _starttime = dbn.graph['starttime']
    _endtime = dbn.graph['endtime'] + 1 # +1 to handle python convention
    if 'time steps' in dbn.graph.keys() :
        _timesteps = dbn.graph['time steps']
    else :
        _timesteps = range(_starttime,_endtime)
    if 'chngpts' in dbn.graph.keys() :
        _chngpts = dbn.graph['chngpts']
    else :
        _chngpts = list()
    actnodes = list([])
    actlines = list([])
    #print _pos.keys()
    
    # Draw nodes of graph
    for _node in _pos.keys():
        _nodelist = list([_node])
        _alpha = 1.    # TODO: substitute proper value
        actnodes.append(nx.draw_networkx_nodes(dbn,pos=_pos,alpha=_alpha,nodelist=_nodelist,node_shape='o'))
        actnodes[-1].set_edgecolor('r')    # _colour)
        actnodes[-1].set_picker(1)
        actnodes[-1].set_label(_node)
        #if 'chngpts' in dbn.graph.keys() and (int(_node[-1]) in _chngpts[_node[:-1]]) :    # Disable for Lorne poster
        #if (_node[:7]=="transwz") or (_node[:5]=='crwz5') :
        if (_node[-2] == "5") or (_node[:7]=="transwz") :
            actnodes[-1].set_color('b')    # _colour)
            actnodes[-1].set_edgecolor('b')    # _colour)
    #for _target,_chngpts in dbn.graph['chngpts'].iteritems() :
    widthcoeff = 5.    # Determines ratio between regression coeff and line width
#    print dbn.adjacency_iter() 

    # Draw edges of graph
    for _causal,_edge in dbn.adjacency_iter():    # dbn.edges_iter() :    # Draw edges individually adjusting thickness and transparency
        for _target,_eattr in _edge.items():
            _alpha = _eattr['postprob']
            #print 'eattr',_eattr,_target,_causal
            if _alpha > cutoff :
                _width = min(abs(_eattr['coeff'])*widthcoeff,10)    #Cut-off width at 10 to keep graph legible
                if _eattr['coeff'] < 0 :
                    _style = 'dashed'
                else :
                    _style = 'solid'
                actlines.append(nx.draw_networkx_edges(dbn,pos=_pos,edgelist=list([(_causal,_target)]),width=_width,alpha=_alpha,style=_style,arrows=False))
                actlines[-1].set_picker(2)
                actlines[-1].set_label((_causal,_target))
                #actlines[-1].set_linestyle(_linestyle)
            
    # Label graph and its axes
    _figtitle = ""    # sys.argv[1]
    #dbnfig = plt.figure()
    if 'nb_records' in dbn.graph.keys() :
        _figtitle += "                                   %i individuals"%dbn.graph['nb_records']
    plt.title(_figtitle)    #
    plt.xlabel("year")
    plt.ylabel("")    #
    
    # Interactive features (currently disabled)
    #fig.canvas.mpl_connect('pick_event',on_event)    
#    ax = plt.gca()
    _nodes = node_labels(dbn.graph['nodes'])    # Provide suitable graph labels
    #ax.xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(1))
    _nodeheight = len(_nodes)
    _yscale = 1.75
    plt.xticks(range(_starttime,_endtime),_timesteps)
    plt.yticks(list(_yscale*i for i in xrange(_nodeheight)),_nodes)
    plt.text(0.55,-1.5,"line width - strength      line shade - posterior probability\nsolid / dashed - positive / negative effect")
    #plt.subplot(111).legend()
    #_drawout = "/Users/walkerm1/work/data/figures/"+_figtitle+".png"
    if not os.path.exists(_outdir) :
        os.mkdir(_outdir)
    plt.ylim([-2,_nodeheight*_yscale])
    
    # Save and display _dbn
    plt.savefig(_drawout)
    plt.show()
    return
    
def dbnpos(_dbn):
    """Function to generate a dictionary of labels for the nodes in the graph.
    returns
    _pos : dict, keys() = dbn.nodes, vals = duple of integer graph coords
    """
    #global dbn
    _nodes = _dbn.graph['nodes']
    nodes = _dbn.nodes()
    _pos = {}
#    for _node in nodes :
#        _nodes.add(_node[:-1])
    _starttime = _dbn.graph['starttime']    
    _endtime = _dbn.graph['endtime']+1    # +1 to accomodate python indexing
    for _step in xrange(_starttime,_endtime):
        _nodeno = 0
        _xcoord = 1 * (_step-_starttime) + 1
        for _node in _nodes:    #_dbn.graph['nodes']:
            _ycoord = 1.75 * _nodeno
            _nodeno += 1
            _name = _node+str(_step)
            if _name in nodes :
                _pos[_name] = tuple([_xcoord,_ycoord])
    return _pos
    

def node_labels(_nodes):
    """Generates list of labels reflecting the data field represented by each node.
    Parameter:
        _nodes - list of default node names
    Returns: 
        _labels - list
    """
    _dictlist = labels_dict()    # Obtain dictionary of human-readable label components
    _labels = list([])
    for _node in _nodes :
        _node = odd_labels(_node)    # Handle unusual nodes
        _nodeparts = split(_node,'_')    # Separate compound node
        #_crwz = 'crwz' in _nodeparts
        _read_label = ""
        for _part in _nodeparts :    # Cycle through parts
            if strip(_part) == "" :    #Skip cycle for empty parts    #TODO: reimplement with reverse loop
                continue
            _suffix = ""
            _prefix = ""
            if _part[-1] == "5" and len(_nodes) == 1 :    # Deal with crwz5
                _prefix = "fifth-year\n"
                _part = _part[:-1]
            if _part[-1] in digits :    #['1','2','3','4','5'] :    # Identify boundary nodes
                _suffix = _part[-1]    # Record year, empty by default
                _part = _part[:-1]    # Process root of node name
            _part += "R"
            for _dict in _dictlist : # Cycle through every dictionary of text replacement
                _part,_read_label = gen_labels(_part,_read_label,_dict)
            _part = strip(_part)
            if _part != "R" and _read_label != "" : # If partially processed...
                _read_label += " "                 # ...remainder needs space
            _read_label += _part[:-1]  + _suffix + '\n'
        _read_label = _prefix + _read_label[:-1]
        _labels.append(_read_label)
    return _labels
    
def odd_labels(_node) :
    """Processes _nodes with unusual names to be processable by rest of node_labels()
    returns: string
    """
    if _node == 'p6_5' : # If _node supposed to contain '_'
            _node = 'P6 5'  #TODO: Replace with dictionary of such _nodes
    elif _node[-3:] in ['g4_'] :
        pass    # Do not process as IL-4. Catch later as IgG4
    elif _node[-2:] in ['5_','4_','9_'] : 
        _node = _node[:-2] + " IL-" + _node[-2]
    elif _node[-2:] == 'g_' :
            print "IFN-gamma"
            _node = _node[:-2] + '.\nIFN-gamma'
    elif _node[-3:] in ['10_','13_'] :
        _node = _node[:-3] + " IL-" + _node[-3:-1]
    return _node

def gen_labels(_node,_gen_label,_dict) :
    """Generates contributions to human readable _gen_label from _node using _dict.
    """
    for _sub,_newsub in _dict.iteritems() :
        if _sub in _node :
            _node = replace(_node,_sub,"")
            _gen_label += _newsub
    return _node,_gen_label
    
def labels_dict():
    """Generates list of dictionaries. Key is portions of labels, item is human-readable label
    portions. 
    NOTE: Order of list affects order in final labels, so order carefully.
    """
    _dictlist = list()
    _dictlist.append({'vp114':'VP1-14 ', 'vp11b':'VP1-1b ', 'pspa1':'PspA1 ','pspa2':'PspA2 ','pspc':'PspC '})
    _dictlist.append({'crcatexp':'cat exposure'})
    _dictlist.append({'lg':'log ', 'g1_R':'IgG1', 'g4_R':'IgG4'})
    _dictlist.append({'mhdm':'mRNA hdm'})
    _dictlist.append({'hdm':'mite ','pnt':'peanut ','cou':'couch ','rye':'rye ','mou':'mould ','cat':'cat ','phinf':'phadiatop ','sae':'Staph aureus\n','p6':'P6 ','grs':'grass '})
    _dictlist.append({'tt':'tetanus ','ova':'ovalbumin '})
    _dictlist.append({'ige':'IgE', 'gR':'IgG', 'igg':'IgG'})
    _dictlist.append({'transwz': 'transient\nwheeze', 'crwz5': 'fifth-year\nwheeze'})
    _dictlist.append({'aiheNOcrwz':'aeroatopy_without_crwz'})
    _dictlist.append({'x':'pure '})
    _dictlist.append({'wflrihrv':'wheezy febrile hrv inf', 'fwlrihrv':'wheezy febrile hrv inf'})
    _dictlist.append({'wlrihrv':'wheezy hrv inf', 'flrihrv':'febrile hrv inf', 'mlrihrv':'mild hrv inf', 'slrihrv':'severe hrv inf'})
    _dictlist.append({'lrihrv':'lower hrv inf','urihrv':'upper hrv inf'})
    _dictlist.append({'hrv':'total hrv'})
    _dictlist.append({'wlrirsv':'wheezy rsv inf', 'flrirsv':'febrile rsv inf', 'mlrirsv':'mild rsv inf', 'slrirsv':'severe rsv inf'})
    _dictlist.append({'lrirsv':'lower rsv inf','urirsv':'upper rsv inf'})
    _dictlist.append({'rsv':'total rsv'})
    _dictlist.append({'wlriother':'wheezy non-hrv\nviral inf', 'flriother':'febrile non-hrv\nviral inf', 'mlriother':'mild non-hrv\nviral inf', 'slriother':'severe non-hrv\nviral inf'})
    _dictlist.append({'lriother':'lower non-hrv\nviral inf','uriother':'upper non-hrv\nviral inf'})
    _dictlist.append({'hrv':'total hrv'})
    _dictlist.append({'wflrianyv':'wheezy febrile viral inf', 'wlrianyv':'wheezy viral inf', 'flrianyv':'febrile viral inf', 'mlrianyv':'mild viral inf', 'slrianyv':'severe viral inf'})
    _dictlist.append({'wflrinotv':'wheezy febrile non-viral inf', 'wlrinotv':'wheezy non-viral inf', 'flrinotv':'febrile non-viral inf', 'mlrinotv':'mild non-viral inf', 'slrinotv':'severe non-viral inf'})
    _dictlist.append({'lrianyv':'lower viral inf','urianyv':'upper viral inf','lrinotv':'lower non-viral inf','urinotv':'upper non-viral inf'})
    _dictlist.append({'wflrimv':'wheezy febrile \nmulti-viral inf', 'wlrimv':'wheezy multi-\nviral inf', 'flrimv':'febrile multi-\nviral inf', 'mlrimv':'mild multi-\nviral inf', 'slrimv':'severe multi-\nviral inf'})
    _dictlist.append({'lrimv':'lower multi-\nviral inf','urimv':'upper multi-\nviral inf'})
    _dictlist.append({'wflri':'wheezy febrile inf', 'fwlri':'wheezy febrile inf'})
    _dictlist.append({'wlri':'wheezy inf', 'flri':'febrile inf', 'mlri':'mild inf', 'slri':'severe inf','furi':'febrile uri'})
    _dictlist.append({'lri':'lower inf','uri':'upper inf'})
    _dictlist.append({'anyvmv':'\nmulti vrs','anyvonev':'\nsngle vrs','notv':'\nno vrs'})
    _dictlist.append({'non':'non'})
    _dictlist.append({'IGEaeroatopyCOUNT':'number of\naero-atopies', 'IGEatopyCOUNT':'number of\natopies'})
    _dictlist.append({'atopy5':'atopic ', 'atopy10':'atopic ', 'ae':'atopy', 'aihe':'aero-atopy', 'aeNOTaihe':'nonaero-atopy'})
    _dictlist.append({'crwz':'wheeze', 'crez':'eczema'})
    _dictlist.append({'6m':'6m'})
    _dictlist.append({'_and_':'and','_plus_':'plus','_minus_':'minus','_with_':'with','_without_':'without'})
    return _dictlist
    
def on_event(event):
    """testing events
    """
    global widthcoeff
    print event
    _artist = event.artist
    _label = _artist.get_label()
    _postprob = _artist.get_alpha()
    #_linestyle = _artist.get_linestyle()[0]    #
    _linestyle = matplotlib.artist.get(_artist,'linestyle')[0]
    if _linestyle[0] == 0 :    # If the linestyle is dashed, meaning negative sign
        _regresssign = -1
    else :
        _regresssign = 1    # Otherwise, solid line, +ve coeff
    _regression = _regresssign * event.artist.get_linewidths()[0]
    _regression /= widthcoeff
    if False and find(_label,',') == -1 :    # Clicked a node...# TODO: replace implementation using isinstance()
        EasyDialogs.Message("Node %s" %(_label))
    else :                         # clicked an edge?
        EasyDialogs.Message("Edge %s\nPosterior probability: %f\nRegression coeff: %f" %(_label,_postprob,_regression))
    return
    